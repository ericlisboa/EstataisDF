# Importando as bibliotecas
import streamlit as st
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objs as go
import base64
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
file_path = r"C:\Users\Eric\OneDrive\Estudos\RBCIP\Estatais\Dashboard\Arquivos VS Code\BD_Completo_Nacional_Formatado.csv"
df = pd.read_csv(file_path)

# ConfiguraÃ§Ãµes da pÃ¡gina
st.set_page_config(
    page_title="Qual o resultado financeiro das estatais para o Governo do DF?",
    page_icon="ðŸ“ˆ",
    layout="wide"
)

st.header("Qual o resultado financeiro das estatais para o Governo do DF?", divider="green")

# ConteÃºdo especÃ­fico desta pÃ¡gina
st.write("""

Nesta seÃ§Ã£o, de forma geral, pretende-se apurar, em relaÃ§Ã£o aos Ãºltimos anos, quanto o Distrito Federal transferiu Ã s empresas como reforÃ§o de capital ou como subvenÃ§Ãµes e quanto recebeu de dividendos das empresas, ou seja, verificar se houve repasses ou recebimento lÃ­quido de forma a entender o impacto fiscal das estatais nas finanÃ§as do Distrito Federal.

""")	

st.subheader("Resultado LÃ­quido das Empresas para o Estado em 2023", divider="green")

st.write("""

O grÃ¡fico apresentado abaixo evidencia os resultados lÃ­quidos das estatais distritais em 2023, destacando a contribuiÃ§Ã£o financeira de cada empresa para o Governo do DF. No topo do ranking, o BRB - Banco Regional de BrasÃ­lia, junto de suas subsidiÃ¡rias, aparece como o principal gerador de lucros, com um resultado lÃ­quido superior a R$ 322 milhÃµes, consolidando-se como um ativo estratÃ©gico para o equilÃ­brio fiscal. O desempenho do BRB reflete uma gestÃ£o eficiente, diversificaÃ§Ã£o de receitas e operaÃ§Ãµes sÃ³lidas no mercado financeiro, posicionando-o como uma fonte confiÃ¡vel de retorno ao estado.

Em contraste, setores como habitaÃ§Ã£o e urbanizaÃ§Ã£o e transporte pÃºblico apresentaram os maiores prejuÃ­zos. A NOVACAP, por exemplo, registrou um dÃ©ficit significativo de mais de R$ 341 milhÃµes. 

Outro destaque negativo Ã© a EMATER, que tambÃ©m apresentou prejuÃ­zo expressivo, refletindo dificuldades no financiamento de suas operaÃ§Ãµes e no cumprimento de seu papel estratÃ©gico no setor agropecuÃ¡rio. Da mesma forma, empresas como a CODHAB e a SAB operaram com resultados lÃ­quidos negativos, reforÃ§ando a necessidade de maior eficiÃªncia na gestÃ£o de recursos e de estratÃ©gias voltadas Ã  sustentabilidade financeira.

""")	

# Filtrar os dados apropriados de 'DF' em 2023
df_filtrado = df[(df["Estado"] == "DF") & (df["Ano"] == 2023)].copy()

# Verificar se hÃ¡ dados disponÃ­veis
if len(df_filtrado) == 0:
    st.warning("NÃ£o hÃ¡ dados disponÃ­veis para o DF no ano de 2023.")
else:
    # Ordenar os resultados do maior para o menor
    df_filtrado.sort_values(
        by="Resultado para o Estado Acionista", ascending=True, inplace=True
    )
    
    # Adicionar informaÃ§Ã£o de dependÃªncia para anÃ¡lise
    if "dep" in df_filtrado.columns:
        df_filtrado["DependÃªncia"] = df_filtrado["dep"].apply(
            lambda x: "Dependente" if str(x).upper() == "DEPENDENTE" else "NÃ£o Dependente"
        )
    
    # Calcular estatÃ­sticas para contextualizaÃ§Ã£o
    total_resultado = df_filtrado["Resultado para o Estado Acionista"].sum()
    empresas_positivas = df_filtrado[df_filtrado["Resultado para o Estado Acionista"] > 0]
    empresas_negativas = df_filtrado[df_filtrado["Resultado para o Estado Acionista"] < 0]
    
    # MÃ©tricas de contexto
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric(
            "Resultado LÃ­quido Total", 
            f"R$ {total_resultado:,.2f}",
            delta=None
        )
    
    with col2:
        st.metric(
            "Empresas com Resultado Positivo", 
            f"{len(empresas_positivas)}",
            f"{len(empresas_positivas)/len(df_filtrado)*100:.1f}%"
        )
    
    with col3:
        st.metric(
            "Empresas com Resultado Negativo", 
            f"{len(empresas_negativas)}",
            f"{len(empresas_negativas)/len(df_filtrado)*100:.1f}%",
            delta_color="inverse"
        )
    
    # Criando o grÃ¡fico de barras com Plotly Express
    fig = px.bar(
        df_filtrado,
        x="Resultado para o Estado Acionista",
        y="emp",
        orientation="h",
        text="Resultado para o Estado Acionista",
        color="Resultado para o Estado Acionista",
        color_continuous_scale=["#F46045", "#F46045", "#007acc", "#007acc"],
        color_continuous_midpoint=0,
        labels={
            "Resultado para o Estado Acionista": "Valor (R$)", 
            "emp": "Empresa"
        },
        hover_data={
            "Resultado para o Estado Acionista": ":,.2f",
            "setor": True,
            "DependÃªncia": True
        } if "dep" in df_filtrado.columns and "setor" in df_filtrado.columns else None
    )
    
    # Atualizar template de hover e texto
    fig.update_traces(
        hovertemplate=(
            "<b>%{y}</b><br>"
            "Resultado: R$ %{x:,.2f}<br>"
            "Setor: %{customdata[0]}<br>"
            "DependÃªncia: %{customdata[1]}<extra></extra>"
        ) if "dep" in df_filtrado.columns and "setor" in df_filtrado.columns else
        "<b>%{y}</b><br>Resultado: R$ %{x:,.2f}<extra></extra>",
        texttemplate="R$ %{x:,.2f}",
        textposition="outside",
        textfont=dict(color="black", size=10),
        cliponaxis=False
    )
    
    # Linha de referÃªncia no zero
    fig.add_vline(
        x=0, 
        line_dash="dash", 
        line_color="gray",
        annotation_text="Linha Zero", 
        annotation_position="top"
    )
    
    # Ajustar o layout
    fig.update_layout(
        height=800,  # Altura adaptativa com base no nÃºmero de empresas
        plot_bgcolor="white",
        paper_bgcolor="white",
        title={
            "text": "<b>Resultado LÃ­quido das Estatais para o Governo do DF em 2023</b>",
            "y": 0.98,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"size": 20, "color": "black"}
        },
        xaxis=dict(
            title=dict(text="Resultado para o Estado Acionista (R$)", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="lightgray",
            zerolinecolor="black",
            zerolinewidth=1.5,
            # Ajustar o limite automÃ¡tico ou definir um intervalo especÃ­fico se necessÃ¡rio
            # range=[-1.5e9, 1e9]
        ),
        yaxis=dict(
            title=dict(text="Empresa", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="white"
        ),
        coloraxis_showscale=False,  # Ocultar a escala de cores
        margin=dict(l=50, r=120, t=80, b=50)  # Aumentar margem direita para texto
    )
    
    # Exibir o grÃ¡fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)
    
    # Adicionar seÃ§Ã£o expansÃ­vel com detalhes
    with st.expander("ðŸ“Š Ver detalhes do resultado financeiro"):
        # Tabela com todos os dados relevantes
        tabela = df_filtrado[["emp", "Resultado para o Estado Acionista", "setor"]] if "setor" in df_filtrado.columns else df_filtrado[["emp", "Resultado para o Estado Acionista"]]
        
        if "dep" in df_filtrado.columns:
            tabela["DependÃªncia"] = df_filtrado["DependÃªncia"]
        
        # Renomear colunas para melhor visualizaÃ§Ã£o
        tabela.columns = ["Empresa", "Resultado para o Estado (R$)"] + (["Setor"] if "setor" in df_filtrado.columns else []) + (["DependÃªncia"] if "dep" in df_filtrado.columns else [])
        
        # Ordenar por resultado (maior para menor)
        tabela = tabela.sort_values(by="Resultado para o Estado (R$)", ascending=False)
        
        # Exibir tabela formatada
        st.dataframe(
            tabela,
            column_config={
                "Resultado para o Estado (R$)": st.column_config.NumberColumn(
                    "Resultado para o Estado (R$)",
                    format="R$ %.2f"
                )
            },
            hide_index=True,
            use_container_width=True
        )
        
        # AnÃ¡lise adicional
        col1, col2 = st.columns(2)
        
        with col1:
            if len(empresas_positivas) > 0:
                try:
                    # Encontrar empresa com maior resultado positivo
                    melhor_valor = empresas_positivas["Resultado para o Estado Acionista"].max()
                    melhor_empresa = empresas_positivas[empresas_positivas["Resultado para o Estado Acionista"] == melhor_valor].iloc[0]
                    
                    st.success(f"**Empresa com melhor resultado**: {melhor_empresa['emp']}")
                    st.write(f"Valor: **R$ {melhor_empresa['Resultado para o Estado Acionista']:,.2f}**")
                    
                    if "setor" in melhor_empresa and pd.notna(melhor_empresa["setor"]):
                        st.write(f"Setor: {melhor_empresa['setor']}")
                except (IndexError, KeyError) as e:
                    st.info("NÃ£o foi possÃ­vel determinar a empresa com melhor resultado.")
                    st.write(f"Erro: {str(e)}")
            else:
                st.info("NÃ£o hÃ¡ empresas com resultado positivo no perÃ­odo.")
        
        with col2:
            if len(empresas_negativas) > 0:
                try:
                    # Encontrar empresa com pior resultado negativo
                    pior_valor = empresas_negativas["Resultado para o Estado Acionista"].min()
                    pior_empresa = empresas_negativas[empresas_negativas["Resultado para o Estado Acionista"] == pior_valor].iloc[0]
                    
                    st.error(f"**Empresa com pior resultado**: {pior_empresa['emp']}")
                    st.write(f"Valor: **R$ {pior_empresa['Resultado para o Estado Acionista']:,.2f}**")
                    
                    if "setor" in pior_empresa and pd.notna(pior_empresa["setor"]):
                        st.write(f"Setor: {pior_empresa['setor']}")
                except (IndexError, KeyError) as e:
                    st.info("NÃ£o foi possÃ­vel determinar a empresa com pior resultado.")
                    st.write(f"Erro: {str(e)}")
            else:
                st.info("NÃ£o hÃ¡ empresas com resultado negativo no perÃ­odo.")


st.subheader("Resultado LÃ­quido das Empresas para o Estado - acumulado 2020 a 2023", divider="green")

st.write("""

A anÃ¡lise do resultado lÃ­quido acumulado das empresas estatais do Distrito Federal entre 2020 e 2023, grÃ¡fico abaixo, revela um panorama marcante de contrastes financeiros. Enquanto algumas empresas contribuÃ­ram significativamente para as receitas do estado, outras registraram dÃ©ficits expressivos, destacando desafios estruturais e operacionais que precisam ser enfrentados.

No grupo das empresas lucrativas, o BRB - Banco Regional de BrasÃ­lia ocupa o topo do ranking, com um lucro acumulado de mais de 458,7 milhÃµes e R$ 253,3 milhÃµes de reais, respectivamente. Esses nÃºmeros refletem a eficiÃªncia dessas empresas em seus setores de atuaÃ§Ã£o, caracterizados por forte geraÃ§Ã£o de receitas, boa governanÃ§a e estratÃ©gias sÃ³lidas de expansÃ£o e diversificaÃ§Ã£o de negÃ³cios. A contribuiÃ§Ã£o dessas empresas nÃ£o apenas fortalece as finanÃ§as pÃºblicas do Distrito Federal, mas tambÃ©m evidencia o impacto positivo de uma gestÃ£o orientada para resultados.

Por outro lado, os resultados negativos sÃ£o liderados pela NOVACAP - Companhia Urbanizadora da Nova Capital do Brasil, que acumulou um prejuÃ­zo impressionante de mais de 1,1 bilhÃ£o e 1,03 bilhÃ£o de reais, respectivamente. Esses nÃºmeros destacam a vulnerabilidade de setores que dependem fortemente de subsÃ­dios governamentais ou enfrentam dificuldades na geraÃ§Ã£o de receitas prÃ³prias. Os prejuÃ­zos recorrentes dessas empresas reforÃ§am a necessidade de intervenÃ§Ãµes estruturais, como reavaliaÃ§Ã£o de modelos operacionais, parcerias pÃºblico-privadas e adoÃ§Ã£o de tecnologias para melhorar a eficiÃªncia.

Empresas como a EMATER, a CODHAB, e o TCB - Sociedade de Transportes Coletivos de BrasÃ­lia tambÃ©m apresentaram resultados negativos significativos, evidenciando dificuldades em equilibrar suas operaÃ§Ãµes financeiras com as exigÃªncias de suas missÃµes sociais. Esses setores, frequentemente associados a serviÃ§os essenciais, enfrentam desafios para alinhar a sustentabilidade financeira com a prestaÃ§Ã£o de serviÃ§os de qualidade para a populaÃ§Ã£o.

""")	

# Filtrar os dados entre 2020 e 2023 para o estado DF
df_filtrado = df[(df["Estado"] == "DF") & (df["Ano"].between(2020, 2023))].copy()

# Verificar se hÃ¡ dados disponÃ­veis
if len(df_filtrado) == 0:
    st.warning("NÃ£o hÃ¡ dados disponÃ­veis para o DF entre 2020 e 2023.")
else:
    # Agrupar por empresa e somar os resultados entre os anos desejados
    df_agrupado = df_filtrado.groupby("emp", as_index=False).agg({
        "Resultado para o Estado Acionista": "sum",
        "setor": "first"  # Preservar o setor para anÃ¡lise
    }) if "setor" in df_filtrado.columns else df_filtrado.groupby("emp", as_index=False).agg({
        "Resultado para o Estado Acionista": "sum"
    })
    
    # Ordenar os resultados em ordem crescente para visualizaÃ§Ã£o
    df_agrupado.sort_values(
        by="Resultado para o Estado Acionista", ascending=True, inplace=True
    )
    
    # Calcular estatÃ­sticas para contextualizaÃ§Ã£o
    total_resultado = df_agrupado["Resultado para o Estado Acionista"].sum()
    empresas_positivas = df_agrupado[df_agrupado["Resultado para o Estado Acionista"] > 0]
    empresas_negativas = df_agrupado[df_agrupado["Resultado para o Estado Acionista"] < 0]
    
    # MÃ©tricas de resumo
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Resultado LÃ­quido Acumulado", 
            f"R$ {total_resultado:,.2f}",
            delta=None
        )
    
    with col2:
        st.metric(
            "Empresas com Saldo Positivo", 
            f"{len(empresas_positivas)}",
            f"{len(empresas_positivas)/len(df_agrupado)*100:.1f}%"
        )
    
    with col3:
        st.metric(
            "Empresas com Saldo Negativo", 
            f"{len(empresas_negativas)}",
            f"{len(empresas_negativas)/len(df_agrupado)*100:.1f}%",
            delta_color="inverse"
        )
    
    # Criar o grÃ¡fico de barras com Plotly Express
    fig = px.bar(
        df_agrupado,
        x="Resultado para o Estado Acionista",
        y="emp",
        orientation="h",
        text="Resultado para o Estado Acionista",
        color="Resultado para o Estado Acionista",
        color_continuous_scale=["#F46045", "#F46045", "#007acc", "#007acc"],
        color_continuous_midpoint=0,
        labels={
            "Resultado para o Estado Acionista": "Valor Acumulado (R$)", 
            "emp": "Empresa"
        },
        hover_data={
            "Resultado para o Estado Acionista": ":,.2f",
            "setor": True
        } if "setor" in df_agrupado.columns else None
    )
    
    # Configurar formataÃ§Ã£o do texto e hover
    fig.update_traces(
        hovertemplate=(
            "<b>%{y}</b><br>"
            "Resultado Acumulado: R$ %{x:,.2f}<br>"
            "Setor: %{customdata[0]}<extra></extra>"
        ) if "setor" in df_agrupado.columns else
        "<b>%{y}</b><br>Resultado Acumulado: R$ %{x:,.2f}<extra></extra>",
        texttemplate="R$ %{x:,.2f}",
        textposition="outside",
        textfont=dict(color="black", size=10),
        cliponaxis=False
    )
    
    # Linha de referÃªncia no zero
    fig.add_vline(
        x=0, 
        line_dash="dash", 
        line_color="gray",
        annotation_text="Linha Zero", 
        annotation_position="top"
    )
    
    # Ajustar o layout
    fig.update_layout(
        height=800,
        plot_bgcolor="white",
        paper_bgcolor="white",
        title={
            "text": "<b>Resultado LÃ­quido Acumulado das Estatais para o Governo do DF (2020-2023)</b>",
            "y": 0.98,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"size": 20, "color": "black"}
        },
        xaxis=dict(
            title=dict(text="Resultado para o Estado Acionista (R$)", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="lightgray",
            zerolinecolor="black",
            zerolinewidth=1.5,
            # Ajustar o limite para que todos os dados sejam visÃ­veis
            # range=[-5e9, 1.5e9]
        ),
        yaxis=dict(
            title=dict(text="Empresa", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="white"
        ),
        coloraxis_showscale=False,  # Ocultar a escala de cores
        margin=dict(l=50, r=150, t=80, b=50)  # Aumentar margem direita para acomodar valores
    )
    
    # Exibir o grÃ¡fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)
    
    # Adicionar seÃ§Ã£o expandÃ­vel com detalhes
    with st.expander("ðŸ“Š Ver detalhes do resultado financeiro acumulado"):
        # Tabela com todos os dados relevantes
        tabela = df_agrupado[["emp", "Resultado para o Estado Acionista", "setor"]] if "setor" in df_agrupado.columns else df_agrupado[["emp", "Resultado para o Estado Acionista"]]
        
        # Renomear colunas para melhor visualizaÃ§Ã£o
        nomes_colunas = ["Empresa", "Resultado Acumulado para o Estado (R$)"]
        if "setor" in tabela.columns:
            nomes_colunas.append("Setor")
        tabela.columns = nomes_colunas
        
        # Ordenar por resultado (maior para menor)
        tabela = tabela.sort_values(by="Resultado Acumulado para o Estado (R$)", ascending=False)
        
        # Exibir tabela formatada
        st.dataframe(
            tabela,
            column_config={
                "Resultado Acumulado para o Estado (R$)": st.column_config.NumberColumn(
                    "Resultado Acumulado para o Estado (R$)",
                    format="R$ %.2f"
                )
            },
            hide_index=True,
            use_container_width=True
        )
        
        # AnÃ¡lise adicional - Top empresas positivas e negativas
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("### Empresas com maior saldo positivo")
            if len(empresas_positivas) > 0:
                top_positivas = empresas_positivas.nlargest(5, "Resultado para o Estado Acionista")
                for i, row in enumerate(top_positivas.itertuples(), 1):
                    st.success(f"{i}. **{row.emp}**")
                    st.write(f"Resultado: R$ {row._2:,.2f}")
                    if hasattr(row, "setor") and pd.notna(row.setor):
                        st.write(f"Setor: {row.setor}")
                    st.write("---")
            else:
                st.info("NÃ£o hÃ¡ empresas com saldo positivo no perÃ­odo.")
        
        with col2:
            st.markdown("### Empresas com maior saldo negativo")
            if len(empresas_negativas) > 0:
                top_negativas = empresas_negativas.nsmallest(5, "Resultado para o Estado Acionista")
                for i, row in enumerate(top_negativas.itertuples(), 1):
                    st.error(f"{i}. **{row.emp}**")
                    st.write(f"Resultado: R$ {row._2:,.2f}")
                    if hasattr(row, "setor") and pd.notna(row.setor):
                        st.write(f"Setor: {row.setor}")
                    st.write("---")
            else:
                st.info("NÃ£o hÃ¡ empresas com saldo negativo no perÃ­odo.")


st.subheader("Resultado LÃ­quido para o Estado, por Setor - acumulado 2020 a 2023", divider="green")

st.write("""

O grÃ¡fico abaixo apresenta o resultado lÃ­quido acumulado das empresas estatais do Distrito Federal por setor de atuaÃ§Ã£o entre 2020 e 2023, destacando disparidades marcantes no desempenho financeiro de diferentes segmentos. Os setores de financeiro e energia foram os Ãºnicos a apresentar resultados lÃ­quidos positivos, enquanto outros setores, especialmente habitaÃ§Ã£o e urbanizaÃ§Ã£o, acumularam prejuÃ­zos significativos, evidenciando desafios estruturais e operacionais.

O setor financeiro, liderado pelo BRB e suas subsidiÃ¡rias, alcanÃ§ou um resultado lÃ­quido acumulado de mais de R$ 253 milhÃµes, tambÃ©m demonstrou solidez, impulsionado pela CEB e suas subsidiÃ¡rias, que se beneficiaram de estratÃ©gias de modernizaÃ§Ã£o e otimizaÃ§Ã£o de operaÃ§Ãµes de geraÃ§Ã£o e distribuiÃ§Ã£o de energia.

Em contrapartida, o setor de habitaÃ§Ã£o e urbanizaÃ§Ã£o registrou o maior dÃ©ficit acumulado, com prejuÃ­zo superior a R$ 1,3 bilhÃ£o, destacando a dificuldade em equilibrar custos operacionais elevados e receitas insuficientes para cobrir despesas. Esses nÃºmeros reforÃ§am a necessidade de reavaliaÃ§Ãµes estratÃ©gicas nesses setores, com foco em reestruturaÃ§Ã£o e maior eficiÃªncia na utilizaÃ§Ã£o dos recursos pÃºblicos.

Setores como gestÃ£o de ativos e pesquisa e assistÃªncia tÃ©cnica agropecuÃ¡ria tambÃ©m apresentaram resultados negativos, com dÃ©ficits de R$ 378 milhÃµes, respectivamente. 

Esses setores enfrentam desafios para equilibrar sua relevÃ¢ncia social com a sustentabilidade financeira. O setor de saneamento, em contraste, registrou um leve superÃ¡vit de R$ 11 milhÃµes, destacando a CAESB como uma empresa capaz de manter resultados positivos, mesmo em um ambiente operacional complexo.

""")	

# Filtrar os dados entre 2020 e 2023 para o estado DF
df_filtrado = df[(df["Estado"] == "DF") & (df["Ano"].between(2020, 2023))].copy()

# Verificar se hÃ¡ dados disponÃ­veis
if len(df_filtrado) == 0:
    st.warning("NÃ£o hÃ¡ dados disponÃ­veis para o DF entre 2020 e 2023.")
else:
    # Agrupar por setor e somar os resultados entre os anos desejados
    df_agrupado_por_setor = df_filtrado.groupby("setor", as_index=False).agg(
        {
            "Resultado para o Estado Acionista": "sum",
            "emp": lambda x: list(sorted(set(x))),  # Lista de empresas Ãºnicas por setor
        }
    )
    
    # Adicionar coluna com nÃºmero de empresas e lista formatada para exibiÃ§Ã£o
    df_agrupado_por_setor["num_empresas"] = df_agrupado_por_setor["emp"].apply(len)
    df_agrupado_por_setor["empresas_lista"] = df_agrupado_por_setor["emp"].apply(lambda x: ", ".join(x))
    
    # Ordenar os resultados do maior para o menor
    df_agrupado_por_setor.sort_values(
        by="Resultado para o Estado Acionista", ascending=True, inplace=True
    )
    
    # Calcular estatÃ­sticas para contextualizaÃ§Ã£o
    total_resultado = df_agrupado_por_setor["Resultado para o Estado Acionista"].sum()
    setores_positivos = df_agrupado_por_setor[df_agrupado_por_setor["Resultado para o Estado Acionista"] > 0]
    setores_negativos = df_agrupado_por_setor[df_agrupado_por_setor["Resultado para o Estado Acionista"] < 0]
    
    # MÃ©tricas de resumo
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Resultado Total por Setor", 
            f"R$ {total_resultado:,.2f}",
            delta=None
        )
    
    with col2:
        st.metric(
            "Setores com Saldo Positivo", 
            f"{len(setores_positivos)}",
            f"{len(setores_positivos)/len(df_agrupado_por_setor)*100:.1f}% dos setores"
        )
    
    with col3:
        st.metric(
            "Setores com Saldo Negativo", 
            f"{len(setores_negativos)}",
            f"{len(setores_negativos)/len(df_agrupado_por_setor)*100:.1f}% dos setores",
            delta_color="inverse"
        )
    
    # Criar o grÃ¡fico de barras com Plotly Express
    fig = px.bar(
        df_agrupado_por_setor,
        x="Resultado para o Estado Acionista",
        y="setor",
        orientation="h",
        text="Resultado para o Estado Acionista",
        color="Resultado para o Estado Acionista",
        color_continuous_scale=["#F46045", "#F46045", "#007acc", "#007acc"],
        color_continuous_midpoint=0,
        labels={
            "Resultado para o Estado Acionista": "Valor Acumulado (R$)", 
            "setor": "Setor",
            "empresas_lista": "Empresas",
            "num_empresas": "NÃºmero de Empresas"
        },
        hover_data={
            "Resultado para o Estado Acionista": ":,.2f",
            "empresas_lista": True,
            "num_empresas": True
        }
    )
    
    # Configurar formataÃ§Ã£o do texto e hover
    fig.update_traces(
        hovertemplate=(
            "<b>%{y}</b><br>"
            "Resultado Acumulado: R$ %{x:,.2f}<br>"
            "Empresas (%{customdata[1]}): %{customdata[0]}<extra></extra>"
        ),
        texttemplate="R$ %{x:,.2f}",
        textposition="outside",
        textfont=dict(color="black", size=12),
        cliponaxis=False
    )
    
    # Linha de referÃªncia no zero
    fig.add_vline(
        x=0, 
        line_dash="dash", 
        line_color="gray",
        annotation_text="Linha Zero", 
        annotation_position="top"
    )
    
    # Ajustar o layout
    fig.update_layout(
        height=600,
        plot_bgcolor="white",
        paper_bgcolor="white",
        title={
            "text": "<b>Resultado LÃ­quido para o Estado por Setor (2020-2023)</b>",
            "y": 0.98,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"size": 20, "color": "black"}
        },
        xaxis=dict(
            title=dict(text="Resultado para o Estado Acionista (R$)", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="lightgray",
            zerolinecolor="black",
            zerolinewidth=1.5,
            # Ajustar o limite para que todos os dados sejam visÃ­veis
            range=[-4.5e9, 2e9]
        ),
        yaxis=dict(
            title=dict(text="Setor", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="white"
        ),
        coloraxis_showscale=False,  # Ocultar a escala de cores
        margin=dict(l=50, r=150, t=80, b=50)  # Aumentar margem direita para acomodar valores
    )
    
    # Exibir o grÃ¡fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)
    
    # Adicionar seÃ§Ã£o expandÃ­vel com detalhes por setor
    with st.expander("ðŸ“Š Ver detalhes dos resultados por setor"):
        # Preparar tabela detalhada
        tabela = df_agrupado_por_setor[["setor", "Resultado para o Estado Acionista", "empresas_lista", "num_empresas"]].copy()
        tabela.columns = ["Setor", "Resultado Acumulado (R$)", "Empresas", "NÃºmero de Empresas"]
        
        # Ordenar por resultado (maior para menor)
        tabela = tabela.sort_values(by="Resultado Acumulado (R$)", ascending=False)
        
        # Exibir tabela formatada
        st.dataframe(
            tabela,
            column_config={
                "Resultado Acumulado (R$)": st.column_config.NumberColumn(
                    "Resultado Acumulado (R$)",
                    format="R$ %.2f"
                ),
                "Empresas": st.column_config.TextColumn(
                    "Empresas",
                    width="large"
                )
            },
            hide_index=True,
            use_container_width=True
        )
        
        # AnÃ¡lise adicional dos setores
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("### Setor com melhor resultado")
            if len(setores_positivos) > 0:
                # Encontrar o setor com melhor resultado
                melhor_setor = setores_positivos.iloc[setores_positivos["Resultado para o Estado Acionista"].idxmax()]
                st.success(f"**{melhor_setor['setor']}**")
                st.write(f"Resultado: **R$ {melhor_setor['Resultado para o Estado Acionista']:,.2f}**")
                st.write(f"Empresas ({melhor_setor['num_empresas']}): {melhor_setor['empresas_lista']}")
            else:
                st.info("NÃ£o hÃ¡ setores com saldo positivo no perÃ­odo.")
        
        with col2:
            st.markdown("### Setor com pior resultado")
            if len(setores_negativos) > 0:
                # Encontrar o setor com pior resultado
                pior_setor = setores_negativos.iloc[setores_negativos["Resultado para o Estado Acionista"].idxmin()]
                st.error(f"**{pior_setor['setor']}**")
                st.write(f"Resultado: **R$ {pior_setor['Resultado para o Estado Acionista']:,.2f}**")
                st.write(f"Empresas ({pior_setor['num_empresas']}): {pior_setor['empresas_lista']}")
            else:
                st.info("NÃ£o hÃ¡ setores com saldo negativo no perÃ­odo.")


st.subheader("Resultado LÃ­quido para o Estado Acionista, por DependÃªncia - 2020 a 2023 acumulado", divider="green")

st.write("""

O grÃ¡fico a seguir ilustra o resultado lÃ­quido acumulado das empresas estatais do Distrito Federal entre 2020 e 2023, categorizando-as em dependentes e nÃ£o dependentes, conforme a classificaÃ§Ã£o estabelecida pela Lei de Responsabilidade Fiscal (LRF). O contraste entre os dois grupos Ã© significativo: as empresas dependentes acumularam um prejuÃ­zo total de R$  306,7 milhÃµes. Esses dados refletem disparidades na capacidade de geraÃ§Ã£o de receitas e eficiÃªncia operacional entre os dois grupos.

As empresas dependentes, por definiÃ§Ã£o, necessitam de aportes financeiros do governo para custear despesas operacionais, salariais e de capital, o que compromete sua autonomia financeira e aumenta sua vulnerabilidade a variaÃ§Ãµes no orÃ§amento pÃºblico. Setores como habitaÃ§Ã£o, transporte e assistÃªncia tÃ©cnica agropecuÃ¡ria, amplamente representados entre as empresas dependentes, enfrentam desafios estruturais como custos elevados e receitas insuficientes para cobrir as despesas, o que contribui para o dÃ©ficit expressivo registrado. Essa dependÃªncia reflete nÃ£o apenas limitaÃ§Ãµes operacionais, mas tambÃ©m a dificuldade em equilibrar a prestaÃ§Ã£o de serviÃ§os essenciais com a sustentabilidade financeira.

Em contraste, as empresas nÃ£o dependentes demonstraram maior capacidade de geraÃ§Ã£o de resultados positivos. O lucro acumulado de R$ 306,7 milhÃµes foi impulsionado, principalmente, pelos setores financeiro e energÃ©tico, liderados por empresas como o BRB e a CEB, que possuem modelos de negÃ³cios diversificados e operaÃ§Ãµes mais orientadas ao mercado. Essas organizaÃ§Ãµes se destacam por sua eficiÃªncia em utilizar seus recursos patrimoniais para gerar retorno financeiro ao estado, sem demandar aportes governamentais regulares. Esse contraste evidencia o impacto da autonomia financeira e da governanÃ§a corporativa na performance das estatais, reforÃ§ando a necessidade de estratÃ©gias diferenciadas para cada grupo.

A anÃ¡lise do perÃ­odo acumulado de 2020 a 2023 expÃµe a importÃ¢ncia de priorizar polÃ­ticas pÃºblicas que promovam eficiÃªncia operacional e sustentabilidade financeira, principalmente para empresas dependentes. Ao mesmo tempo, os resultados das empresas nÃ£o dependentes confirmam o valor estratÃ©gico de investir em setores capazes de gerar retornos consistentes ao estado, garantindo maior equilÃ­brio fiscal e alÃ­vio Ã  necessidade de subsÃ­dios governamentais.

""")	

# Filtrar os dados entre 2020 e 2023 para o estado DF
df_filtrado = df[(df["Estado"] == "DF") & (df["Ano"].between(2020, 2023))].copy()

# Verificar se hÃ¡ dados disponÃ­veis e a coluna de dependÃªncia existe
if len(df_filtrado) == 0:
    st.warning("NÃ£o hÃ¡ dados disponÃ­veis para o DF entre 2020 e 2023.")
elif "dep" not in df_filtrado.columns:
    st.warning("A coluna de dependÃªncia nÃ£o estÃ¡ disponÃ­vel nos dados.")
else:
    # Garantir que nÃ£o hÃ¡ valores ausentes na coluna de dependÃªncia
    df_filtrado = df_filtrado.dropna(subset=["dep"])
    
    # Padronizar os valores da coluna de dependÃªncia
    df_filtrado["dep"] = df_filtrado["dep"].apply(
        lambda x: "Dependente" if str(x).upper() == "DEPENDENTE" else "NÃ£o Dependente"
    )
    
    # Agrupar por dependÃªncia e somar os resultados entre os anos desejados
    df_agrupado_por_dep = df_filtrado.groupby("dep", as_index=False).agg({
        "Resultado para o Estado Acionista": "sum",
        "emp": lambda x: list(sorted(set(x))),
        "setor": lambda x: list(sorted(set(x))) if "setor" in df_filtrado.columns else None
    })
    
    # Adicionar colunas para facilitar a exibiÃ§Ã£o
    df_agrupado_por_dep["num_empresas"] = df_agrupado_por_dep["emp"].apply(len)
    df_agrupado_por_dep["empresas_lista"] = df_agrupado_por_dep["emp"].apply(lambda x: ", ".join(x))
    
    if "setor" in df_agrupado_por_dep.columns:
        df_agrupado_por_dep["setores_lista"] = df_agrupado_por_dep["setor"].apply(
            lambda x: ", ".join(x) if x is not None else "N/A"
        )
    
    # Calcular estatÃ­sticas para contextualizaÃ§Ã£o
    total_resultado = df_agrupado_por_dep["Resultado para o Estado Acionista"].sum()
    estatais_dependentes = df_agrupado_por_dep[df_agrupado_por_dep["dep"] == "Dependente"]
    estatais_nao_dependentes = df_agrupado_por_dep[df_agrupado_por_dep["dep"] == "NÃ£o Dependente"]
    
    # Exibir mÃ©tricas resumidas
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Resultado Total", 
            f"R$ {total_resultado:,.2f}",
            delta=None
        )
    
    with col2:
        if not estatais_dependentes.empty:
            resultado_dependentes = estatais_dependentes["Resultado para o Estado Acionista"].iloc[0]
            st.metric(
                "Estatais Dependentes", 
                f"R$ {resultado_dependentes:,.2f}",
                delta=f"{resultado_dependentes/total_resultado*100:.1f}%" if total_resultado != 0 else None,
                delta_color="off" if resultado_dependentes < 0 else "normal"
            )
        else:
            st.metric("Estatais Dependentes", "Dados nÃ£o disponÃ­veis")
    
    with col3:
        if not estatais_nao_dependentes.empty:
            resultado_nao_dependentes = estatais_nao_dependentes["Resultado para o Estado Acionista"].iloc[0]
            st.metric(
                "Estatais NÃ£o Dependentes", 
                f"R$ {resultado_nao_dependentes:,.2f}",
                delta=f"{resultado_nao_dependentes/total_resultado*100:.1f}%" if total_resultado != 0 else None,
                delta_color="off" if resultado_nao_dependentes < 0 else "normal"
            )
        else:
            st.metric("Estatais NÃ£o Dependentes", "Dados nÃ£o disponÃ­veis")
    
    # Criar o grÃ¡fico de barras com Plotly Express
    fig = px.bar(
        df_agrupado_por_dep,
        x="dep",
        y="Resultado para o Estado Acionista",
        orientation="v",
        text="Resultado para o Estado Acionista",
        color="Resultado para o Estado Acionista",
        color_continuous_scale=["#F46045", "#F46045", "#007acc", "#007acc"],
        color_continuous_midpoint=0,
        labels={
            "Resultado para o Estado Acionista": "Valor Acumulado (R$)", 
            "dep": "DependÃªncia"
        },
        hover_data={
            "Resultado para o Estado Acionista": ":,.2f",
            "num_empresas": True,
            "empresas_lista": True,
            "setores_lista": True if "setores_lista" in df_agrupado_por_dep.columns else False
        }
    )
    
    # Configurar formataÃ§Ã£o do texto e hover
    if "setores_lista" in df_agrupado_por_dep.columns:
        hover_template = (
            "<b>%{x}</b><br>"
            "Resultado Acumulado: R$ %{y:,.2f}<br>"
            "NÃºmero de Empresas: %{customdata[0]}<br>"
            "Empresas: %{customdata[1]}<br>"
            "Setores: %{customdata[2]}<extra></extra>"
        )
    else:
        hover_template = (
            "<b>%{x}</b><br>"
            "Resultado Acumulado: R$ %{y:,.2f}<br>"
            "NÃºmero de Empresas: %{customdata[0]}<br>"
            "Empresas: %{customdata[1]}<extra></extra>"
        )
    
    fig.update_traces(
        hovertemplate=hover_template,
        texttemplate="R$ %{y:,.2f}",
        textposition="outside",
        textfont=dict(color="black", size=14),
        marker_line_width=1,
        marker_line_color="gray",
        cliponaxis=False
    )
    
    # Linha de referÃªncia no zero
    fig.add_hline(
        y=0, 
        line_dash="dash", 
        line_color="gray",
        annotation_text="Linha Zero", 
        annotation_position="right"
    )
    
    # Ajustar o layout
    fig.update_layout(
        height=600,
        plot_bgcolor="white",
        paper_bgcolor="white",
        title={
            "text": "<b>Resultado LÃ­quido para o Estado por DependÃªncia (2020-2023)</b>",
            "y": 0.95,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"size": 20, "color": "black"}
        },
        xaxis=dict(
            title=dict(text="DependÃªncia", font=dict(size=16, color="black")),
            tickfont=dict(size=14, color="black"),
            gridcolor="white"
        ),
        yaxis=dict(
            title=dict(text="Resultado para o Estado Acionista (R$)", font=dict(size=16, color="black")),
            tickfont=dict(size=14, color="black"),
            gridcolor="lightgray",
            zerolinecolor="black",
            zerolinewidth=1.5,
            # Ajustar a escala para melhor visualizaÃ§Ã£o
            # range=[-7e9, 1e9]
        ),
        coloraxis_showscale=False,  # Ocultar a escala de cores
        bargap=0.4,  # Aumentar o espaÃ§o entre barras
        margin=dict(l=50, r=50, t=80, b=50)
    )
    
    # Adicionar comparaÃ§Ã£o visual entre grupos
    for i, row in df_agrupado_por_dep.iterrows():
        fig.add_annotation(
            x=row["dep"],
            y=row["Resultado para o Estado Acionista"],
            text=f"{row['num_empresas']} empresas",
            showarrow=False,
            font=dict(size=12, color="black"),
            bgcolor="rgba(255, 255, 255, 0.8)",
            bordercolor="gray",
            borderwidth=1,
            borderpad=4,
            yshift=30 if row["Resultado para o Estado Acionista"] < 0 else -30
        )
    
    # Exibir o grÃ¡fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)
    
    # Adicionar seÃ§Ã£o expandÃ­vel com detalhes
    with st.expander("ðŸ“Š Ver detalhes por dependÃªncia"):
        # Preparar dados para exibiÃ§Ã£o
        for dep_type in df_agrupado_por_dep["dep"].unique():
            st.markdown(f"### {dep_type}")
            
            # Obter dados do grupo
            grupo = df_agrupado_por_dep[df_agrupado_por_dep["dep"] == dep_type].iloc[0]
            
            # Exibir resultado
            if grupo["Resultado para o Estado Acionista"] >= 0:
                st.success(f"**Resultado Acumulado**: R$ {grupo['Resultado para o Estado Acionista']:,.2f}")
            else:
                st.error(f"**Resultado Acumulado**: R$ {grupo['Resultado para o Estado Acionista']:,.2f}")
            
            # Exibir detalhes
            st.write(f"**NÃºmero de Empresas**: {grupo['num_empresas']}")
            
            # Criar tabela de empresas
            empresas_df = pd.DataFrame({
                "Empresa": grupo["emp"]
            })
            
            # Filtrar dados destas empresas para mostrar resultados individuais
            if len(grupo["emp"]) > 0:
                resultados_individuais = df_filtrado[df_filtrado["emp"].isin(grupo["emp"])].groupby("emp", as_index=False).agg({
                    "Resultado para o Estado Acionista": "sum",
                    "setor": "first" if "setor" in df_filtrado.columns else None
                })
                
                # Mesclar com a tabela de empresas
                if "setor" in resultados_individuais.columns:
                    empresas_df = empresas_df.merge(
                        resultados_individuais[["emp", "Resultado para o Estado Acionista", "setor"]],
                        left_on="Empresa",
                        right_on="emp",
                        how="left"
                    ).drop(columns=["emp"])
                else:
                    empresas_df = empresas_df.merge(
                        resultados_individuais[["emp", "Resultado para o Estado Acionista"]],
                        left_on="Empresa",
                        right_on="emp",
                        how="left"
                    ).drop(columns=["emp"])
                
                # Ordenar por resultado
                empresas_df = empresas_df.sort_values(by="Resultado para o Estado Acionista", ascending=False)
                
                # Renomear colunas
                empresas_df.columns = ["Empresa", "Resultado (R$)"] + (["Setor"] if "setor" in resultados_individuais.columns else [])
                
                # Exibir tabela
                st.dataframe(
                    empresas_df,
                    column_config={
                        "Resultado (R$)": st.column_config.NumberColumn(
                            "Resultado (R$)",
                            format="R$ %.2f"
                        )
                    },
                    hide_index=True,
                    use_container_width=True
                )
            
            st.markdown("---")


st.subheader("Resultado LÃ­quido Total para o Estado - acumulado 2020 a 2023", divider="green")

st.write("""

O grÃ¡fico abaixo apresenta a evoluÃ§Ã£o do resultado lÃ­quido total das empresas estatais do Distrito Federal para o Governo, no perÃ­odo de 2020 a 2023, destacando uma trajetÃ³ria predominantemente negativa. Ao longo dos quatro anos, o acumulado reflete dÃ©ficits significativos, com Ãªnfase no ano de 2022, que registrou o maior prejuÃ­zo, totalizando R$ -2,1 bilhÃµes. Essa deterioraÃ§Ã£o acentuada pode ser atribuÃ­da a uma combinaÃ§Ã£o de fatores, como desafios macroeconÃ´micos, aumento de custos operacionais, e limitaÃ§Ãµes na geraÃ§Ã£o de receitas prÃ³prias em setores estratÃ©gicos como transporte, habitaÃ§Ã£o e urbanizaÃ§Ã£o.

O ano de 2020 tambÃ©m apresentou um resultado negativo expressivo, com um dÃ©ficit total de R$ 1,15 bilhÃ£o, refletindo esforÃ§os de recuperaÃ§Ã£o econÃ´mica, mas ainda marcado por fragilidades operacionais e desafios estruturais.

No entanto, em 2023, observa-se uma reduÃ§Ã£o significativa no dÃ©ficit total, que foi reduzido para R$ -927 milhÃµes, representando o menor prejuÃ­zo do perÃ­odo analisado. Esse resultado pode indicar uma tendÃªncia de recuperaÃ§Ã£o financeira, impulsionada por melhorias na governanÃ§a corporativa e maior eficiÃªncia em setores como financeiro e energia, que contribuÃ­ram positivamente para mitigar os impactos negativos de outras Ã¡reas deficitÃ¡rias. Apesar da melhora relativa, o acumulado negativo ao longo dos anos destaca a necessidade de aÃ§Ãµes mais estruturantes para reverter a trajetÃ³ria de prejuÃ­zos, garantindo maior sustentabilidade financeira para as empresas pÃºblicas do Distrito Federal.

""")	

# Filtrar os dados entre 2020 e 2023 para o estado DF
df_filtrado = df[(df["Estado"] == "DF") & (df["Ano"].between(2020, 2023))].copy()

# Verificar se hÃ¡ dados disponÃ­veis
if len(df_filtrado) == 0:
    st.warning("NÃ£o hÃ¡ dados disponÃ­veis para o DF entre 2020 e 2023.")
else:
    # Agrupar por ano e somar os resultados para cada ano
    df_agrupado_por_ano = df_filtrado.groupby("Ano", as_index=False).agg({
        "Resultado para o Estado Acionista": "sum"
    })
    
    # Ordenar os resultados por ano (crescente)
    df_agrupado_por_ano.sort_values(by="Ano", ascending=True, inplace=True)
    
    # Adicionar coluna formatada para exibiÃ§Ã£o
    df_agrupado_por_ano["Resultado Formatado"] = df_agrupado_por_ano["Resultado para o Estado Acionista"].apply(
        lambda x: f"R$ {x:,.2f}"
    )
    
    # Calcular estatÃ­sticas para contextualizaÃ§Ã£o
    total_acumulado = df_agrupado_por_ano["Resultado para o Estado Acionista"].sum()
    media_anual = df_agrupado_por_ano["Resultado para o Estado Acionista"].mean()
    pior_ano = df_agrupado_por_ano.loc[df_agrupado_por_ano["Resultado para o Estado Acionista"].idxmin()]
    melhor_ano = df_agrupado_por_ano.loc[df_agrupado_por_ano["Resultado para o Estado Acionista"].idxmax()]
    
    # Exibir mÃ©tricas resumidas
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Resultado Total Acumulado", 
            f"R$ {total_acumulado:,.2f}",
            delta=None
        )
    
    with col2:
        st.metric(
            "MÃ©dia Anual", 
            f"R$ {media_anual:,.2f}",
            delta=None
        )
    
    with col3:
        # Comparar o resultado do Ãºltimo ano com o do ano anterior
        if len(df_agrupado_por_ano) >= 2:
            ultimo_ano = df_agrupado_por_ano.iloc[-1]
            penultimo_ano = df_agrupado_por_ano.iloc[-2]
            variacao = ultimo_ano["Resultado para o Estado Acionista"] - penultimo_ano["Resultado para o Estado Acionista"]
            variacao_percentual = (variacao / abs(penultimo_ano["Resultado para o Estado Acionista"])) * 100 if penultimo_ano["Resultado para o Estado Acionista"] != 0 else 0
            
            st.metric(
                f"VariaÃ§Ã£o {ultimo_ano['Ano']}/{penultimo_ano['Ano']}", 
                f"R$ {variacao:,.2f}",
                f"{variacao_percentual:.1f}%",
                delta_color="normal" if variacao > 0 else "inverse"
            )
        else:
            st.metric("VariaÃ§Ã£o Anual", "Dados insuficientes")
    
    # Criar o grÃ¡fico de barras com Plotly Express
    fig = px.bar(
        df_agrupado_por_ano,
        x="Resultado para o Estado Acionista",
        y="Ano",
        orientation="h",
        text="Resultado Formatado",
        labels={
            "Resultado para o Estado Acionista": "Valor (R$)", 
            "Ano": ""  # Remover label do eixo Y para maior limpeza visual
        },
        color="Resultado para o Estado Acionista",
        color_continuous_scale=["#F46045", "#F46045", "#007acc", "#007acc"],
        color_continuous_midpoint=0
    )
    
    # Configurar formataÃ§Ã£o do texto e hover
    fig.update_traces(
        hovertemplate="<b>Ano: %{y}</b><br>Resultado: R$ %{x:,.2f}<extra></extra>",
        textposition="outside",
        textfont=dict(color="black", size=12),
        cliponaxis=False
    )
    
    # Linha de referÃªncia no zero
    fig.add_vline(
        x=0, 
        line_dash="dash", 
        line_color="gray",
        annotation_text="Zero", 
        annotation_position="top"
    )
    
    # Adicionar linhas de tendÃªncia
    fig.add_shape(
        type="line",
        x0=df_agrupado_por_ano["Resultado para o Estado Acionista"].min() * 1.05,  # Estender um pouco alÃ©m do mÃ­nimo
        y0=df_agrupado_por_ano["Ano"].min(),
        x1=df_agrupado_por_ano["Resultado para o Estado Acionista"].max() * 1.05,  # Estender um pouco alÃ©m do mÃ¡ximo
        y1=df_agrupado_por_ano["Ano"].max(),
        line=dict(color="gray", width=1, dash="dot"),
    )
    
    # Ajustar o layout
    fig.update_layout(
        height=400,
        plot_bgcolor="white",
        paper_bgcolor="white",
        title={
            "text": "<b>EvoluÃ§Ã£o do Resultado para o Estado (2020-2023)</b>",
            "y": 0.95,
            "x": 0.5,
            "xanchor": "center",
            "yanchor": "top",
            "font": {"size": 20, "color": "black"}
        },
        xaxis=dict(
            title=dict(text="Resultado para o Estado Acionista (R$)", font=dict(size=14, color="black")),
            tickfont=dict(size=12, color="black"),
            gridcolor="lightgray",
            zerolinecolor="black",
            zerolinewidth=1.5,
            range=[min(df_agrupado_por_ano["Resultado para o Estado Acionista"]) * 1.1, 0]  # Ajustar para que todos os valores sejam visÃ­veis
        ),
        yaxis=dict(
            tickfont=dict(size=14, color="black", weight="bold"),
            gridcolor="white"
        ),
        coloraxis_showscale=False,  # Ocultar a escala de cores
        margin=dict(l=50, r=120, t=80, b=50)  # Aumentar margem direita para acomodar valores
    )
    
    # Adicionar anotaÃ§Ãµes para destacar os valores extremos
    fig.add_annotation(
        x=pior_ano["Resultado para o Estado Acionista"],
        y=pior_ano["Ano"],
        text="Pior resultado",
        showarrow=True,
        arrowhead=2,
        arrowcolor="#F46045",
        arrowsize=1,
        arrowwidth=2,
        ax=-40,
        ay=-30,
        font=dict(size=12, color="#F46045"),
        bgcolor="rgba(255, 255, 255, 0.8)",
        bordercolor="#F46045",
        borderwidth=1,
        borderpad=4
    )
    
    fig.add_annotation(
        x=melhor_ano["Resultado para o Estado Acionista"],
        y=melhor_ano["Ano"],
        text="Melhor resultado",
        showarrow=True,
        arrowhead=2,
        arrowcolor="#007acc",
        arrowsize=1,
        arrowwidth=2,
        ax=-40,
        ay=30,
        font=dict(size=12, color="#007acc"),
        bgcolor="rgba(255, 255, 255, 0.8)",
        bordercolor="#007acc",
        borderwidth=1,
        borderpad=4
    )
    
    # Exibir o grÃ¡fico no Streamlit
    st.plotly_chart(fig, use_container_width=True)
    
    # Adicionar seÃ§Ã£o expandÃ­vel com detalhes
    with st.expander("ðŸ“Š Ver detalhes da evoluÃ§Ã£o anual"):
        # Preparar tabela detalhada
        tabela = df_agrupado_por_ano[["Ano", "Resultado para o Estado Acionista"]].copy()
        tabela.columns = ["Ano", "Resultado (R$)"]
        
        # Calcular variaÃ§Ã£o em relaÃ§Ã£o ao ano anterior
        tabela["VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (R$)"] = tabela["Resultado (R$)"].diff()
        tabela["VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (%)"] = tabela["Resultado (R$)"].pct_change() * 100
        
        # Adicionar linha com o total acumulado
        total_row = pd.DataFrame({
            "Ano": ["Total Acumulado"],
            "Resultado (R$)": [total_acumulado],
            "VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (R$)": [None],
            "VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (%)": [None]
        })
        tabela = pd.concat([tabela, total_row], ignore_index=True)
        
        # Exibir tabela formatada
        st.dataframe(
            tabela,
            column_config={
                "Resultado (R$)": st.column_config.NumberColumn(
                    "Resultado (R$)",
                    format="R$ %.2f"
                ),
                "VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (R$)": st.column_config.NumberColumn(
                    "VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (R$)",
                    format="R$ %.2f"
                ),
                "VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (%)": st.column_config.NumberColumn(
                    "VariaÃ§Ã£o em RelaÃ§Ã£o ao Ano Anterior (%)",
                    format="%.2f%%"
                )
            },
            hide_index=True,
            use_container_width=True
        )
        
        # AnÃ¡lise de tendÃªncia
        st.markdown("### AnÃ¡lise de tendÃªncia")
        
        if df_agrupado_por_ano["Resultado para o Estado Acionista"].iloc[-1] > df_agrupado_por_ano["Resultado para o Estado Acionista"].iloc[0]:
            st.success("**TendÃªncia de melhoria ao longo do perÃ­odo analisado.**")
            st.write(f"O resultado do Ãºltimo ano ({df_agrupado_por_ano['Ano'].iloc[-1]}) foi R$ {df_agrupado_por_ano['Resultado para o Estado Acionista'].iloc[-1] - df_agrupado_por_ano['Resultado para o Estado Acionista'].iloc[0]:,.2f} superior ao do primeiro ano da sÃ©rie ({df_agrupado_por_ano['Ano'].iloc[0]}).")
        else:
            st.error("**TendÃªncia de deterioraÃ§Ã£o ao longo do perÃ­odo analisado.**")
            st.write(f"O resultado do Ãºltimo ano ({df_agrupado_por_ano['Ano'].iloc[-1]}) foi R$ {df_agrupado_por_ano['Resultado para o Estado Acionista'].iloc[0] - df_agrupado_por_ano['Resultado para o Estado Acionista'].iloc[-1]:,.2f} inferior ao do primeiro ano da sÃ©rie ({df_agrupado_por_ano['Ano'].iloc[0]}).")
        
        # VisualizaÃ§Ã£o alternativa - grÃ¡fico de linha
        st.markdown("### EvoluÃ§Ã£o temporal")
        
        fig_line = px.line(
            df_agrupado_por_ano,
            x="Ano",
            y="Resultado para o Estado Acionista",
            markers=True,
            labels={"Resultado para o Estado Acionista": "Resultado (R$)", "Ano": ""}
        )
        
        fig_line.update_traces(
            line=dict(width=3, color="#007acc"),
            marker=dict(size=10, color="#007acc"),
            hovertemplate="<b>Ano: %{x}</b><br>Resultado: R$ %{y:,.2f}<extra></extra>"
        )
        
        fig_line.add_hline(
            y=0, 
            line_dash="dash", 
            line_color="gray",
            annotation_text="EquilÃ­brio", 
            annotation_position="right"
        )
        
        fig_line.update_layout(
            height=350,
            plot_bgcolor="white",
            paper_bgcolor="white",
            xaxis=dict(
                tickmode='array',
                tickvals=df_agrupado_por_ano["Ano"],
                tickfont=dict(size=12, color="black")
            ),
            yaxis=dict(
                title=dict(text="Resultado para o Estado (R$)", font=dict(size=14, color="black")),
                tickfont=dict(size=12, color="black"),
                gridcolor="lightgray",
                zerolinecolor="black",
                zerolinewidth=1.5
            ),
            margin=dict(l=50, r=50, t=30, b=50)
        )
        
        st.plotly_chart(fig_line, use_container_width=True)

# BotÃ£o para voltar Ã  pÃ¡gina inicial
if st.button("Voltar Ã  PÃ¡gina Inicial"):
    st.switch_page("InÃ­cio.py")